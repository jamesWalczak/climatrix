{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf0d climatrix","text":"<p>Climatrix is a flexible toolbox for sampling and reconstructing climate datasets.</p> <p>It provides utilities and an xarray accessor that simplifies the workflow of working with climate data arrays \u2014 from preprocessing to statistical sampling.</p>"},{"location":"#author","title":"\ud83d\udc64 Author","text":"<ul> <li>Name: Jakub Walczak</li> <li>GitHub: @jamesWalczak</li> <li>Email: jakub.walczak@p.lodz.pl</li> </ul>"},{"location":"#contributors","title":"\ud83d\udc65 Contributors","text":"<ul> <li>Name: Wojciech \u017byndul</li> <li>GitHub: @wzyndul</li> <li>Email: 242575@edu.p.lodz.pl</li> </ul>"},{"location":"#version","title":"\ud83d\udccc Version","text":"Alpha release <p>This is an alpha release \u2013 features are still evolving, and breaking changes may occur.</p>"},{"location":"#table-of-contents","title":"\ud83d\udcda Table of Contents","text":"<ul> <li>\ud83d\ude80 Getting Started</li> <li>\ud83d\udce6 Installation</li> <li>\u2699\ufe0f Usage</li> <li>\ud83e\uddea Examples</li> <li>\ud83d\udee0\ufe0f Features</li> <li>\ud83d\udcc4 License</li> <li>\ud83d\ude4f Citation</li> </ul>"},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"Climatrix is now available on PyPI <p>Run <code>pip install climatrix</code> to install.</p> <p>These instructions will get you a copy of the project up and running on your local machine.</p> <pre><code>git clone https://github.com/jamesWalczak/climatrix/\ncd climatrix\n</code></pre>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"PyPI Installation <p>The project is now available via PyPI (<code>pip install climatrix</code>)</p>"},{"location":"#usage","title":"\u2699\ufe0f Usage","text":"<p>Here is a basic example of how to use this project. For more details, refer to API reference or Getting started section.</p>"},{"location":"#examples","title":"\ud83e\uddea Examples","text":"\ud83d\udd0d Click to expand example: Accessing `climatrix` features <pre><code>import climatrix as cm\nimport xarray as xr\n\nmy_dataset = \"/file/to/netcdf.nc\"\ncm_dset = xr.open_dataset(my_dataset).cm\n</code></pre> \ud83d\udcca Click to expand example: Getting values of coordinate <pre><code>import climatrix as cm\nimport xarray as xr\n\nmy_dataset = \"/file/to/netcdf.nc\"\ncm_dset = xr.open_dataset(my_dataset).cm\nprint(\"Latitude values: \", cm_dset.latitude)\nprint(\"Time values: \", cm_dset.time)\n</code></pre> \ud83d\udcca Subsetting by bounding box <pre><code>import climatrix as cm\nimport xarray as xr\n\nmy_dataset = \"/file/to/netcdf.nc\"\ncm_dset = xr.open_dataset(my_dataset).cm\neurope = cm_dset.cm.subset(north=71, south=36, west=-24, east=35)\n</code></pre>"},{"location":"#features","title":"\ud83d\udee0\ufe0f Features","text":"<ul> <li>\ud83e\udded Easy access to coordinate data (similar to MetPy), using regex to locate lat/lon</li> <li>\ud83d\udcca Sampling of climate data, both uniformly and using normal-like distributions</li> <li>\ud83d\udd01 Reconstruction via:</li> <li>IDW (Inverse Distance Weighting)</li> <li>Ordinary Kriging</li> <li>SIREN (Sinusoidal INR)</li> <li>\ud83e\uddea Tools to compare reconstruction results</li> <li>\ud83d\udcc8 Plotting utilities for visualizing inputs and outputs</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"#contributing","title":"\ud83d\udc65 Contributing","text":"<p>The rules for contributing on the project are described in CONTRIBUTING file in details.</p>"},{"location":"#citation","title":"\ud83d\ude4f Citation","text":"<p>If you are using this software in scientific work, cite us:</p> <pre><code>@article{walczak2025climatrix,\n  title={Climatrix: Xarray accessor for climate data sampling and reconstruction},\n  author={Walczak, Jakub and {\\.Z}yndul, Wojciech},\n  journal={SoftwareX},\n  volume={31},\n  pages={102263},\n  year={2025},\n  publisher={Elsevier}\n}\n</code></pre>"},{"location":"CONTRIBUTING/","title":"Contributing Guidelines","text":"<p>Thank you for contributing! Please follow these rules:</p>"},{"location":"CONTRIBUTING/#forks","title":"\ud83c\udf74 Forks","text":"<p>Fork the repository first.</p>"},{"location":"CONTRIBUTING/#commits","title":"\ud83d\udd8a\ufe0f Commits","text":"<ul> <li>All commits must be signed off using <code>git commit -s</code></li> <li>Contributors certify compliance with Developer Certificate of Origin</li> </ul>"},{"location":"CONTRIBUTING/#branch-naming","title":"\ud83c\udf3f Branch Naming","text":"<ul> <li>Use one of the following formats:</li> <li><code>f-&lt;ticket_id&gt;</code> for features (e.g., <code>f-1234</code>)</li> <li><code>b-&lt;ticket_id&gt;</code> for bugfixes (e.g., <code>b-5678</code>)</li> </ul>"},{"location":"CONTRIBUTING/#pull-requests","title":"\ud83d\udce6 Pull Requests","text":"<ul> <li>Make sure your PR is linked to an issue or ticket.</li> <li>Add a clear description of what it does.</li> <li>Don't forget about unit tests.</li> </ul>"},{"location":"CONTRIBUTING/#pre-commit-hooks","title":"\ud83d\udd27 Pre-commit hooks","text":"<p>This repo uses pre-commit for code formatting:</p> <ul> <li><code>black</code> for code style,</li> <li><code>isort</code> for import sorting,</li> <li><code>pre-commit-hook</code> for checking against <code>breakpoint()</code>, private keys, and mixed endline characters,</li> <li><code>pyupgrade</code> for upgrading syntax to newer versions of the language,</li> <li><code>flake8</code> for checking against PEP8 compliance,</li> <li><code>mdformat</code> for Markdown files formatting</li> </ul> <p>To set it up:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"api/","title":"\ud83e\uddea API Reference","text":"<p>Welcome to the <code>climatrix</code> API reference. Below you'll find details on key modules, classes, and methods \u2014 with examples and usage tips to help you integrate it smoothly into your climate data workflows.</p> <p>Abstract</p> <p>The main module <code>climatrix</code> provides tools to extend <code>xarray</code> datasets for climate subsetting, sampling, reconstruction. It is accessible via accessor.</p> <p>The library contains a few public classes:</p> Class name Description <code>AxisType</code> Enumerator class for type of spatio-temporal axes <code>Axis</code> Class managing spatio-temporal axes <code>BaseClimatrixDataset</code> Base class for managing <code>xarray</code> data <code>Domain</code> Base class for domain-specific operations <code>SparseDomain</code> Subclass of <code>Domain</code> aim at managing sparse representations <code>DenseDomain</code> Subclass of <code>Domain</code> aim at managing dense representations <code>Plot</code> Interactive plotting utility for climate datasets"},{"location":"api/#axes","title":"\ud83d\udcc8 Axes","text":""},{"location":"api/#climatrix.dataset.axis.AxisType","title":"<code>climatrix.dataset.axis.AxisType</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for axis types.</p> <p>Attributes:</p> Name Type Description <code>LATITUDE</code> <code>str</code> <p>Latitude axis type.</p> <code>LONGITUDE</code> <code>str</code> <p>Longitude axis type.</p> <code>TIME</code> <code>str</code> <p>Time axis type.</p> <code>VERTICAL</code> <code>str</code> <p>Vertical axis type.</p> <code>POINT</code> <code>str</code> <p>Point axis type.</p>"},{"location":"api/#climatrix.dataset.axis.AxisType.get","title":"<code>get(value)</code>  <code>classmethod</code>","text":"<p>Get the <code>AxisType</code> type given by <code>value</code>.</p> <p>If <code>value</code> is an instance of <code>AxisType</code>, return it as is. If <code>value</code> is a string, return the corresponding <code>AxisType</code>. If <code>value</code> is neither an instance of <code>AxisType</code> nor a string, raise a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str or AxisType</code> <p>The axis type</p> required <p>Returns:</p> Type Description <code>AxisType</code> <p>The axis type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>value</code> is not a valid axis type.</p>"},{"location":"api/#climatrix.dataset.axis.Axis","title":"<code>climatrix.dataset.axis.Axis</code>","text":"<p>Base class for axis types.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>ClassVar[AxisType]</code> <p>The type of the axis.</p> <code>dtype</code> <code>ClassVar[dtype]</code> <p>The data type of the axis values.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p> <code>name</code> <code>str</code> <p>The name of the axis.</p> <code>values</code> <code>ndarray</code> <p>The values of the axis.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the axis.</p> required <code>values</code> <code>ndarray</code> <p>The values of the axis.</p> required <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not (default is True).</p> <code>True</code> <p>Examples:</p> <p>Axis is a factory class for all axis types. To create an axis (by matching the name), use:</p> <pre><code>&gt;&gt;&gt; axis = Axis(name=\"latitude\", values=np.array([1, 2, 3]))\n</code></pre> <p>To create a <code>Latitude</code> axis explicitly, use:</p> <pre><code>&gt;&gt;&gt; axis = Latitude(name=\"latitude\", values=np.array([1, 2, 3]))\n&gt;&gt;&gt; axis = Latitude(\n... name=\"latitude\",\n... values=np.array([1, 2, 3]),\n... is_dimension=True)\n</code></pre> Notes <ul> <li>The <code>Axis</code> class is a factory class for all axis types.</li> <li>If the given axis has \"unusual\" name, you need to create it     explicitly using the corresponding class (e.g. <code>Latitude</code>).</li> </ul>"},{"location":"api/#climatrix.dataset.axis.Axis.size","title":"<code>size</code>  <code>property</code>","text":"<p>Get the size of the axis.</p> <p>Returns:</p> Type Description <code>int</code> <p>The size of the axis.</p>"},{"location":"api/#climatrix.dataset.axis.Axis.matches","title":"<code>matches(name)</code>  <code>classmethod</code>","text":"<p>Check if the axis matches the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the axis matches the name, False otherwise.</p>"},{"location":"api/#climatrix.dataset.axis.Axis.get_all_axes","title":"<code>get_all_axes()</code>  <code>classmethod</code>","text":"<p>Get all axis classes.</p> <p>Returns:</p> Type Description <code>list[Type[Axis]]</code> <p>A list of all axis classes.</p>"},{"location":"api/#climatrix.dataset.axis.Latitude","title":"<code>climatrix.dataset.axis.Latitude</code>","text":"<p>               Bases: <code>Axis</code></p> <p>Latitude axis.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the latitude axis.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p>"},{"location":"api/#climatrix.dataset.axis.Longitude","title":"<code>climatrix.dataset.axis.Longitude</code>","text":"<p>               Bases: <code>Axis</code></p> <p>Longitude axis.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the longitude axis.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p>"},{"location":"api/#climatrix.dataset.axis.Time","title":"<code>climatrix.dataset.axis.Time</code>","text":"<p>               Bases: <code>Axis</code></p> <p>Time axis.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the time axis.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p>"},{"location":"api/#climatrix.dataset.axis.Time.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two axes are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The other object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the axes are equal, False otherwise.</p>"},{"location":"api/#climatrix.dataset.axis.Point","title":"<code>climatrix.dataset.axis.Point</code>","text":"<p>               Bases: <code>Axis</code></p> <p>Point axis.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the point axis.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p>"},{"location":"api/#climatrix.dataset.axis.Vertical","title":"<code>climatrix.dataset.axis.Vertical</code>","text":"<p>               Bases: <code>Axis</code></p> <p>Vertical axis.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the vertical axis.</p> <code>is_dimension</code> <code>bool</code> <p>Whether the axis is a dimension or not.</p>"},{"location":"api/#data","title":"\ud83d\udcc7 Data","text":""},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset","title":"<code>climatrix.dataset.base.BaseClimatrixDataset</code>","text":"<p>Base class for Climatrix workflows.</p> <p>This class provides a set of methods for manipulating xarray datasets. It is designed to be used as an xarray accessor, allowing you to call its methods directly on xarray datasets.</p> <p>The class supports basic arithmetic operations, including: addition, subtraction, multiplication, and division.</p> <p>Attributes:</p> Name Type Description <code>da</code> <code>DataArray</code> <p>The underlying <code>xarray.DataArray</code> object (if single-variable <code>xarray.Dataset</code> was passed, it is squeezed to <code>xarray.DataArray</code>).</p> <code>domain</code> <code>Domain</code> <p>The domain object representing the spatial and temporal dimensions of the dataset. See <code>SparseDomain</code> and <code>DenseDomain</code> for more details.</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.domain","title":"<code>domain = Domain(xarray_obj)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.subset","title":"<code>subset(north=None, south=None, west=None, east=None)</code>","text":"<p>Subset data with the specified bounding box.</p> <p>If an argument is not provided, it means no bounds set in that direction. For example, if <code>north</code> is not provided, it means that the maximum latitude of the dataset will be used. If <code>north</code> and <code>south</code> are provided, the dataset will be subsetted to the area between these two latitudes.</p> <p>Parameters:</p> Name Type Description Default <code>north</code> <code>float</code> <p>North latitude of the bounding box.</p> <code>None</code> <code>south</code> <code>float</code> <p>South latitude of the bounding box.</p> <code>None</code> <code>west</code> <code>float</code> <p>West longitude of the bounding box.</p> <code>None</code> <code>east</code> <code>float</code> <p>East longitude of the bounding box.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>The subsetted dataset.</p> <p>Raises:</p> Type Description <code>LongitudeConventionMismatch</code> <ul> <li>If the dataset is in positive-only convention (longitude \\(\\lambda \\in [0, 360]\\)) and negative values are requested, or vice versa.</li> <li>If the dataset is in signed-longitude convention (longitude \\(\\lambda \\in [-180, 180]\\)) and positive values greater than 360 are requested.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; globe_dset = xr.open_dataset(\"path/to/dataset.nc\")\n&gt;&gt;&gt; globe_dset\n&lt;xarray.Dataset&gt;\nDimensions:  (time: 1, latitude: 180, longitude: 360)\nCoordinates:\n  * time     (time) datetime64[ns] 2020-01-01\n  * latitude (latitude) float64 -90.0 -89.0 -88.0 ... 88.0 89.0\n  * longitude (longitude) float64 0.0 1.0 2.0 ... 357.0 358.0 359.0\nData variables:\n    temperature (time, latitude, longitude) float64 ...\n&gt;&gt;&gt; dset2 = globe_dset.cm.subset(\n...     north=10.0,\n...     south=5.0,\n...     west=20.0,\n...     east=25.0,\n... )\n&gt;&gt;&gt; dset2 = globe_dset.cm.subset(\n...     north=10.0,\n...     south=5.0,\n...     west=-50.0,\n...     east=25.0,\n... )\nLongitudeConventionMismatch: The dataset is in positive-only convention\n(longitude goes from 0 to 360) while you are\nrequesting negative values (longitude goes from -180 to 180).\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.to_signed_longitude","title":"<code>to_signed_longitude()</code>","text":"<p>Convert the dataset to signed longitude convention.</p> <p>The longitude values are converted to be in the range (-180 to 180 degrees).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\").cm\n&gt;&gt;&gt; dset.da\n&lt;xarray.DataArray 'temperature' (time: 1, latitude: 180, longitude: 360)&gt;\n...\nDimensions:  (time: 1, latitude: 180, longitude: 360)\nCoordinates:\n  * time     (time) datetime64[ns] 2020-01-01\n  * latitude (latitude) float64 -90.0 -89.0 -88.0 ... 88.0 89.0\n  * longitude (longitude) float64 0.0 1.0 2.0 ... 357.0 358.0 359.0\nData variables:\n    temperature (time, latitude, longitude) float64 ...\n&gt;&gt;&gt; dset2 = cm.to_signed_longitude()\n&gt;&gt;&gt; dset2.da\n&lt;xarray.DataArray 'temperature' (time: 1, latitude: 180, longitude: 360)&gt;\n...\nDimensions:  (time: 1, latitude: 180, longitude: 360)\nCoordinates:\n  * time     (time) datetime64[ns] 2020-01-01\n  * latitude (latitude) float64 -90.0 -89.0 -88.0 ... 88.0 89.0\n  * longitude (longitude) float64 -180.0 -179.0 -178.0 ... 177.0 178.0 179.0\n</code></pre> References <p>[1] Mancini, M., Walczak, J. Stojiljkovic, M., geokube: A Python    library for geospatial data processing, 2024,    https://doi.org/10.5281/zenodo.10597965 https://github.com/CMCC-Foundation/geokube</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.to_positive_longitude","title":"<code>to_positive_longitude()</code>","text":"<p>Convert the dataset to positive longitude convention.</p> <p>The longitude values are converted to be in the range (0 to 360 degrees).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\").cm\n&gt;&gt;&gt; dset.da\n&lt;xarray.DataArray 'temperature' (time: 1, latitude: 180,\nlongitude: 360)&gt;\n...\nDimensions:  (time: 1, latitude: 180, longitude: 360)\nCoordinates:\n  * time     (time) datetime64[ns] 2020-01-01\n  * latitude (latitude) float64 -90.0 -89.0 -88.0 ... 88.0 89.0\n  * longitude (longitude) float64 -180.0 ... 178.0 179.0\nData variables:\n    temperature (time, latitude, longitude) float64 ...\n&gt;&gt;&gt; dset2 = dset.to_positive_longitude()\n&gt;&gt;&gt; dset2.da\n&lt;xarray.DataArray 'temperature' (time: 1, latitude: 180,\n  longitude: 360)&gt;\n...\nDimensions:  (time: 1, latitude: 180, longitude: 360)\nCoordinates:\n  * time     (time) datetime64[ns] 2020-01-01\n  * latitude (latitude) float64 -90.0 -89.0 -88.0 ... 88.0 89.0\n  * longitude (longitude) float64 0.0 1.0 ... 357.0 358.0 359.0\nData variables:\n    temperature (time, latitude, longitude) float64 ...\n</code></pre> References <p>[1] Mancini, M., Walczak, J. Stojiljkovic, M., geokube: A Python    library for geospatial data processing, 2024,    https://doi.org/10.5281/zenodo.10597965 https://github.com/CMCC-Foundation/geokube</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.squeeze","title":"<code>squeeze()</code>","text":"<p>Squeeze the dataset to remove dimensions of size 1.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The squeezed dataset.</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.profile_along_axes","title":"<code>profile_along_axes(*axes)</code>","text":"<p>Generate profiles along the specified axes.</p> <p>Parameters:</p> Name Type Description Default <code>*axes</code> <code>AxisType | str</code> <p>The axes along which to generate profiles.</p> <code>()</code> <p>Yields:</p> Type Description <code>BaseClimatrixDataset</code> <p>A dataset containing the profile along the specified axes.</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.mask_nan","title":"<code>mask_nan(source)</code>","text":"<p>Apply NaN values from another dataset to the current one.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>BaseClimatrixDataset</code> <p>Dataset whose NaN values will be applied to the current one.</p> required <p>Returns:</p> Type Description <code>BaseClimatrixDataset</code> <p>A new dataset with NaN values applied.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the <code>source</code> argument is not a BaseClimatrixDataset.</p> <code>ValueError</code> <p>If the domain of the <code>source</code> or the current dataset is sparse.</p> <code>DomainMismatchError</code> <p>If the domains of the <code>source</code> and the current dataset do not match.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset1 = xr.open_dataset(\"path/to/dataset1.nc\").cm\n&gt;&gt;&gt; dset2 = xr.open_dataset(\"path/to/dataset2.nc\").cm\n&gt;&gt;&gt; dset1.mask_nan(dset2)\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.time","title":"<code>time(time)</code>","text":"<p>Select data at a specific time or times.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>datetime, np.datetime64, slice, list, or np.ndarray</code> <p>Time or times to be selected.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The dataset with the selected time or times.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\")\n</code></pre> <p>Selecting by <code>datetime</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.time(datetime(2020, 1, 1))\n</code></pre> <p>Selecting by <code>np.datetime64</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.time(np.datetime64(\"2020-01-01\"))\n</code></pre> <p>Selecting by <code>str</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.time(slice(\"2020-01-01\"))\n</code></pre> <p>Selecting by <code>list</code> of any of the above:</p> <pre><code>&gt;&gt;&gt; dset.cm.time([datetime(2020, 1, 1), np.datetime64(\"2020-01-02\")])\n</code></pre> <p>Selecting by <code>slice</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.time(slice(datetime(2020, 1, 1), datetime(2020, 1, 2)))\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.itime","title":"<code>itime(time)</code>","text":"<p>Select time value by index.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>int, list[int], np.ndarray, or slice</code> <p>Time index or indices to be selected.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The dataset with the selected time or times.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\")\n</code></pre> <p>Selecting by <code>int</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.itime(0)\n</code></pre> <p>Selecting by <code>list</code> of <code>int</code>s:</p> <pre><code>&gt;&gt;&gt; dset.cm.itime([0, 1])\n</code></pre> <p>Selecting by <code>slice</code> object:</p> <pre><code>&gt;&gt;&gt; dset.cm.itime(slice(0, 2))\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.sample_uniform","title":"<code>sample_uniform(portion=None, number=None, nan='ignore')</code>","text":"<p>Sample the dataset using a uniform distribution.</p> <p>Parameters:</p> Name Type Description Default <code>portion</code> <code>float</code> <p>Portion of the dataset to be sampled.</p> <code>None</code> <code>number</code> <code>int</code> <p>Number of points to be sampled.</p> <code>None</code> <code>nan</code> <code>SamplingNaNPolicy | str</code> <p>Policy for handling NaN values.</p> <code>'ignore'</code> Notes <p>At least one of <code>portion</code> or <code>number</code> must be provided. Cannot be provided both at the same time.</p> <p>Warns:</p> Type Description <code>TooLargeSamplePortionWarning</code> <p>If the portion exceeds 1.0 or number of points exceeds the number of spatial points in the Domain</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset contains NaN values and <code>nan</code> parameter  (NaN handling policy) is set to <code>SamplingNaNPolicy.RAISE</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\")\n&gt;&gt;&gt; sparse_dset = dset.cm.sample_uniform(portion=0.1)\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.sample_normal","title":"<code>sample_normal(portion=None, number=None, center_point=None, sigma=10.0, nan='ignore')</code>","text":"<p>Sample the dataset using a normal distribution.</p> <p>Parameters:</p> Name Type Description Default <code>portion</code> <code>float</code> <p>Portion of the dataset to be sampled.</p> <code>None</code> <code>number</code> <code>int</code> <p>Number of points to be sampled.</p> <code>None</code> <code>center_point</code> <code>tuple[Longitude, Latitude]</code> <p>Center point for the normal distribution.</p> <code>None</code> <code>sigma</code> <code>float</code> <p>Standard deviation for the normal distribution.</p> <code>10.0</code> <code>nan</code> <code>SamplingNaNPolicy | str</code> <p>Policy for handling NaN values.</p> <code>'ignore'</code> Notes <p>At least one of <code>portion</code> or <code>number</code> must be provided. Cannot be provided both at the same time.</p> <p>Warns:</p> Type Description <code>TooLargeSamplePortionWarning</code> <p>If the portion exceeds 1.0 or number of points exceeds the number of spatial points in the Domain</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset contains NaN values and <code>nan</code> parameter  (NaN handling policy) is set to <code>SamplingNaNPolicy.RAISE</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\")\n&gt;&gt;&gt; sparse_dset = dset.cm.sample_normal(\n...     number=1_000,\n...     center_point=(10.0, 20.0),\n...     sigma=5.0,\n... )\n</code></pre>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.reconstruct","title":"<code>reconstruct(target, *, method, **recon_kwargs)</code>","text":"<p>Reconstruct the dataset to a target domain.</p> <p>If target domain is sparse, the reconstruction will be sparse too. If target domain is dense, the reconstruction will be dense too. The reconstruction will be done using the method specified in the <code>method</code> argument.</p> <p>The method can be one of the following:     Inverse Distance Weightining (<code>idw</code>),     Ordinary Kriging (<code>ok</code>).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Domain</code> <p>The target domain to reconstruct the dataset to.</p> required <code>method</code> <code>ReconstructionType | str</code> <p>The method to use for reconstruction. Can be one of the following: 'idw', 'ok'.</p> required <code>recon_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the reconstruction method.</p> <code>{}</code> See Also <ul> <li><code>climatrix.reconstruct.type.ReconstructionType</code></li> <li><code>climatrix.reconstruct.idw.IDWReconstructor</code></li> <li><code>climatrix.reconstruct.kriging.OrdinaryKrigingReconstructor</code></li> <li><code>climatrix.reconstruct.siren.siren.SIRENReconstructor</code></li> </ul> <p>Returns:</p> Type Description <code>Self</code> <p>The reconstructed dataset.</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.plot","title":"<code>plot(title=None, target=None, show=True, **kwargs)</code>","text":"<p>Plot the dataset on a map.</p> <p>The dataset is plotted using Cartopy and Matplotlib.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the plot. If not provided, the name of the dataset will be used. If the dataset has no name, \"Climatrix Dataset\" will be used.</p> <code>None</code> <code>target</code> <code>str, os.PathLike, Path, or None</code> <p>Path to save the plot. If not provided, the plot will not be saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to show the plot. Default is True.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the plotting function.</p> <ul> <li><code>figsize</code>: tuple, optional     Size of the figure. Default is (12, 6).</li> <li><code>vmin</code>: float, optional     Minimum value for the color scale. Default is None.</li> <li><code>vmax</code>: float, optional     Maximum value for the color scale. Default is None.</li> <li><code>cmap</code>: str, optional     Colormap to use for the plot. Default is \"seismic\".</li> <li><code>ax</code>: Axes, optional     Axes to plot on. If not provided, a new figure and axes     will be created.</li> <li><code>size</code>: int, optional     Size of the points for sparse datasets. Default is 10.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The axes object containing the plot.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the dataset is dynamic (contains time dimension with more than one value).</p>"},{"location":"api/#climatrix.dataset.base.BaseClimatrixDataset.transpose","title":"<code>transpose(*axes)</code>","text":"<p>Transpose the dataset along the specified dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>*axes</code> <code>AxisType or str</code> <p>The axes along which to transpose the dataset.</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>The transposed dataset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import climatrix as cm\n&gt;&gt;&gt; dset = xr.open_dataset(\"path/to/dataset.nc\").cm\n&gt;&gt;&gt; dset2 = dset.transpose(\"longitude\", \"latitude\")\n</code></pre>"},{"location":"api/#domain","title":"\ud83c\udf0d Domain","text":""},{"location":"api/#climatrix.dataset.domain.Domain","title":"<code>climatrix.dataset.domain.Domain</code>","text":"<p>Base class for domain objects.</p> <p>Attributes:</p> Name Type Description <code>is_sparse</code> <code>ClassVar[bool]</code> <p>Indicates if the domain is sparse or dense.</p> <code>_axes</code> <code>dict[AxisType, Axis]</code> <p>Mapping of <code>AxisType</code> to the corresponding <code>Axis</code> object.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.dims","title":"<code>dims</code>  <code>property</code>","text":"<p>Get the dimensions of the dataset.</p> <p>Returns:</p> Type Description <code>tuple[AxisType, ...]</code> <p>A tuple of <code>AxisType</code> objects representing the dimensions of the dataset.</p> Notes <p>The dimensions are determined by the axes that are marked as dimensions in the domain. E.g. if underlying dataset has shape <code>(5, 10, 20)</code>, it means there are 3 dimensional axes.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.latitude","title":"<code>latitude</code>  <code>property</code>","text":"<p>Latitude axis</p>"},{"location":"api/#climatrix.dataset.domain.Domain.longitude","title":"<code>longitude</code>  <code>property</code>","text":"<p>Longitude axis</p>"},{"location":"api/#climatrix.dataset.domain.Domain.time","title":"<code>time</code>  <code>property</code>","text":"<p>Time axis</p>"},{"location":"api/#climatrix.dataset.domain.Domain.point","title":"<code>point</code>  <code>property</code>","text":"<p>Point axis</p>"},{"location":"api/#climatrix.dataset.domain.Domain.vertical","title":"<code>vertical</code>  <code>property</code>","text":"<p>Vertical axis</p>"},{"location":"api/#climatrix.dataset.domain.Domain.is_dynamic","title":"<code>is_dynamic</code>  <code>property</code>","text":"<p>If the domain is dynamic.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.is_sparse","title":"<code>is_sparse</code>  <code>class-attribute</code>","text":""},{"location":"api/#climatrix.dataset.domain.Domain.size","title":"<code>size</code>  <code>property</code>","text":"<p>Domain size.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.all_axes_types","title":"<code>all_axes_types</code>  <code>property</code>","text":"<p>All axis types in the domain.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.from_lat_lon","title":"<code>from_lat_lon(lat=slice(-90, 90, _DEFAULT_LAT_RESOLUTION), lon=slice(-180, 180, _DEFAULT_LON_RESOLUTION), kind='dense')</code>  <code>classmethod</code>","text":"<p>Create a domain from latitude and longitude coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>slice or ndarray</code> <p>Latitude coordinates. If a slice is provided, it will be converted to a numpy array using the specified step.</p> <code>slice(-90, 90, _DEFAULT_LAT_RESOLUTION)</code> <code>lon</code> <code>slice or ndarray</code> <p>Longitude coordinates. If a slice is provided, it will be converted to a numpy array using the specified step.</p> <code>slice(-180, 180, _DEFAULT_LON_RESOLUTION)</code> <code>kind</code> <code>str</code> <p>Type of domain to create. Can be either \"dense\" or \"sparse\". Default is \"dense\".</p> <code>'dense'</code> <p>Returns:</p> Type Description <code>Domain</code> <p>An instance of the Domain class with the specified latitude and longitude coordinates.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.from_axes","title":"<code>from_axes()</code>  <code>classmethod</code>","text":"<p>Create a domain builder for configuring domains with multiple axes.</p> <p>Returns:</p> Type Description <code>DomainBuilder</code> <p>A builder instance for creating domains with various axes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = (Domain.from_axes()\n...           .vertical(depth=slice(10, 100, 1))\n...           .lat(latitude=[1,2,3,4])\n...           .lon(longitude=[1,2,3,4])\n...           .sparse())\n&gt;&gt;&gt; domain = (Domain.from_axes()\n...           .lat(lat=slice(-90, 90, 1))\n...           .lon(lon=slice(-180, 180, 1))\n...           .time(time=['2020-01-01', '2020-01-02'])\n...           .dense())\n</code></pre>"},{"location":"api/#climatrix.dataset.domain.Domain.get_size","title":"<code>get_size(axis)</code>","text":"<p>Get the size of the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisType</code> <p>The axis for which to get the size.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The size of the specified axis.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.has_axis","title":"<code>has_axis(axis)</code>","text":"<p>Check if the specified axis exists in the domain.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisType</code> <p>The axis type to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the axis exists, False otherwise.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.get_axis","title":"<code>get_axis(axis)</code>","text":"<p>Get the name of the specified axis.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>AxisType</code> <p>The axis type for which to get the name.</p> required <p>Returns:</p> Type Description <code>Axis | None</code> <p>The Axis object, or None if not found.</p>"},{"location":"api/#climatrix.dataset.domain.Domain.get_all_spatial_points","title":"<code>get_all_spatial_points()</code>  <code>abstractmethod</code>","text":""},{"location":"api/#climatrix.dataset.domain.Domain.to_xarray","title":"<code>to_xarray(values, name=None)</code>  <code>abstractmethod</code>","text":""},{"location":"api/#climatrix.dataset.domain.SparseDomain","title":"<code>climatrix.dataset.domain.SparseDomain</code>","text":"<p>               Bases: <code>Domain</code></p> <p>Sparse domain class.</p> <p>Supports operations on sparse spatial domain.</p>"},{"location":"api/#climatrix.dataset.domain.SparseDomain.to_xarray","title":"<code>to_xarray(values, name=None)</code>","text":"<p>Convert domain to sparse xarray.DataArray.</p> <p>The method applies <code>values</code> and (optionally) <code>name</code> to create a new xarray.DataArray object based on the domain.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>The values to be assigned to the DataArray variable.</p> required <code>name</code> <code>str</code> <p>The name of the DataArray variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The xarray.DataArray single variable object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape of <code>values</code> does not match the expected shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_lat_lon()\n&gt;&gt;&gt; values = np.random.rand(5, 5)\n&gt;&gt;&gt; da = domain.to_xarray(values, name=\"example\")\n&gt;&gt;&gt; isinstance(da, xr.DataArray)\nTrue\n&gt;&gt;&gt; da.name\n'example'\n</code></pre>"},{"location":"api/#climatrix.dataset.domain.SparseDomain.get_all_spatial_points","title":"<code>get_all_spatial_points()</code>","text":"<p>Get all spatial points in the domain.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of shape (n_points, 2) containing the latitude and longitude coordinates of all points in the domain.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; points = domain.get_all_spatial_points()\n&gt;&gt;&gt; points\narray([[ 0. , -0.1],\n       [ 0. ,  0. ],\n       [ 0. ,  0.1],\n       ...\n</code></pre>"},{"location":"api/#climatrix.dataset.domain.DenseDomain","title":"<code>climatrix.dataset.domain.DenseDomain</code>","text":"<p>               Bases: <code>Domain</code></p> <p>Dense domain class.</p> <p>Supports operations on dense spatial domain.</p>"},{"location":"api/#climatrix.dataset.domain.DenseDomain.to_xarray","title":"<code>to_xarray(values, name=None)</code>","text":"<p>Convert domain to dense xarray.DataArray.</p> <p>The method applies <code>values</code> and (optionally) <code>name</code> to create a new xarray.DataArray object based on the domain.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>The values to be assigned to the DataArray variable.</p> required <code>name</code> <code>str</code> <p>The name of the DataArray variable.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The xarray.DataArray single variable object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the shape of <code>values</code> does not match the expected shape.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain = Domain.from_lat_lon()\n&gt;&gt;&gt; values = np.random.rand(5, 5)\n&gt;&gt;&gt; da = domain.to_xarray(values, name=\"example\")\n&gt;&gt;&gt; isinstance(da, xr.DataArray)\nTrue\n&gt;&gt;&gt; da.name\n'example'\n</code></pre>"},{"location":"api/#climatrix.dataset.domain.DenseDomain.get_all_spatial_points","title":"<code>get_all_spatial_points()</code>","text":"<p>Get all spatial points in the domain.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>An array of shape (n_points, 2) containing the latitude and longitude coordinates of all points in the domain.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; points = domain.get_all_spatial_points()\n&gt;&gt;&gt; points\narray([[ 0. , -0.1],\n       [ 0. ,  0. ],\n       [ 0. ,  0.1],\n       ...\n</code></pre>"},{"location":"api/#interactive-plotting","title":"\ud83d\udcc8 Interactive Plotting","text":""},{"location":"api/#climatrix.plot.core.Plot","title":"<code>climatrix.plot.core.Plot</code>","text":""},{"location":"api/#climatrix.plot.core.Plot.show","title":"<code>show(port=5000, debug=False)</code>","text":""},{"location":"api/#reconstructors","title":"\ud83c\udf10 Reconstructors","text":""},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor","title":"<code>climatrix.reconstruct.base.BaseReconstructor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all dataset reconstruction methods.</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>BaseClimatrixDataset</code> <p>The dataset to be reconstructed.</p> <code>target_domain</code> <code>Domain</code> <p>The target domain for the reconstruction.</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Register subclasses automatically.</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.get","title":"<code>get(method)</code>  <code>classmethod</code>","text":"<p>Get a reconstruction class by method name.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The reconstruction method name (e.g., 'idw', 'ok', 'sinet', 'siren').</p> required <p>Returns:</p> Type Description <code>type[BaseReconstructor]</code> <p>The reconstruction class.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the method is not supported.</p> Notes <p>The <code>method</code> parameter should reflect the <code>NAME</code> class attribute of the selected reconstructor class.</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.get_available_methods","title":"<code>get_available_methods()</code>  <code>classmethod</code>","text":"<p>Get a list of available reconstruction methods.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of method names (e.g., 'idw', 'ok', 'sinet', 'siren').</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.get_hparams","title":"<code>get_hparams()</code>  <code>classmethod</code>","text":"<p>Get hyperparameter definitions from Hyperparameter descriptors.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, any]]</code> <p>Dictionary mapping parameter names to their definitions. Each parameter definition contains: - 'type': the parameter type - 'bounds': tuple of (min, max) for numeric parameters (if defined) - 'values': list of valid values for categorical parameters (if defined) - 'default': default value (if defined)</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.reconstruct","title":"<code>reconstruct()</code>  <code>abstractmethod</code>","text":"<p>Reconstruct the dataset using the specified method.</p> <p>This is an abstract method that must be implemented by subclasses.</p> <p>The data are reconstructed for the target domain, passed in the initializer.</p> <p>Returns:</p> Type Description <code>BaseClimatrixDataset</code> <p>The reconstructed dataset.</p>"},{"location":"api/#climatrix.reconstruct.base.BaseReconstructor.update_bounds","title":"<code>update_bounds(bounds=None, values=None)</code>  <code>classmethod</code>","text":"<p>Update the bounds of hyperparameters in the class.</p> <p>If bound is defined as tuple, it represents a range (min, max). If as a list, it represents a set of valid values.</p> <p>Parameters:</p> Name Type Description Default <code>**bounds</code> <code>dict[str, tuple]</code> <p>Keyword arguments where keys are hyperparameter names and values are tuples defining new bounds.</p> <code>None</code>"},{"location":"api/#climatrix.reconstruct.idw.IDWReconstructor","title":"<code>climatrix.reconstruct.idw.IDWReconstructor</code>","text":"<p>               Bases: <code>BaseReconstructor</code></p> <p>Inverse Distance Weighting Reconstructor</p> <p>This class performs spatial interpolation using inverse distance weighting, where the influence of each known data point on the interpolated value decreases with distance according to a power function.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BaseClimatrixDataset</code> <p>The input dataset to reconstruct.</p> required <code>target_domain</code> <code>Domain</code> <p>The target domain for reconstruction.</p> required <code>power</code> <code>float</code> <p>The power to raise the distance to (default is 2.0). Controls the rate of decrease of influence with distance. Type: float, bounds: , default: 2.0 <code>None</code> <code>k</code> <code>int</code> <p>The number of nearest neighbors to consider (default is 5). Type: int, bounds: (1, ...), default: 5</p> <code>None</code> <code>k_min</code> <code>int</code> <p>The minimum number of nearest neighbors to consider (if k &lt; k_min) NaN values will be put (default is 2). Type: int, bounds: (1, ...)&gt;, default: 2</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the input dataset is dynamic, as IDW reconstruction is not yet supported for dynamic datasets.</p> <code>ValueError</code> <p>If k_min is greater than k or if k is less than 1.</p> Notes <p>Hyperparameters for optimization:     - power: float in (1e-10, 5.0), default=2.0     - k: int in (1, 50), default=5     - k_min: int in (1, 40), default=2</p>"},{"location":"api/#climatrix.reconstruct.idw.IDWReconstructor.reconstruct","title":"<code>reconstruct()</code>","text":"<p>Perform Inverse Distance Weighting (IDW) reconstruction.</p> <p>This method reconstructs the sparse dataset using IDW, taking into account the specified number of nearest neighbors and the power to which distances are raised. The reconstructed data is returned as a dense dataset, either static or dynamic based on the input dataset.</p> <p>Returns:</p> Type Description <code>BaseClimatrixDataset</code> <p>The reconstructed dataset on the target domain.</p> Notes <ul> <li>If fewer than <code>self.k_min</code> neighbors are available, NaN values are assigned to the corresponding points in the output.</li> </ul>"},{"location":"api/#climatrix.reconstruct.kriging.OrdinaryKrigingReconstructor","title":"<code>climatrix.reconstruct.kriging.OrdinaryKrigingReconstructor</code>","text":"<p>               Bases: <code>BaseReconstructor</code></p> <p>Reconstruct a sparse dataset using Ordinary Kriging.</p> <p>This class performs spatial interpolation using ordinary kriging, a geostatistical method that provides optimal linear unbiased estimation by modeling spatial correlation through variograms.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>SparseDataset</code> <p>The sparse dataset to reconstruct.</p> required <code>target_domain</code> <code>Domain</code> <p>The target domain for reconstruction.</p> required <code>backend</code> <code>Literal['vectorized', 'loop'] | None</code> <p>The backend to use for kriging (default is None).</p> <code>None</code> <code>nlags</code> <code>int | None</code> <p>Number of lags for variogram computation (default is 6). Type: int, bounds: (0, ...), default: 6</p> <code>None</code> <code>anisotropy_scaling</code> <code>float | None</code> <p>Anisotropy scaling factor (default is 1e-6). Type: float, bounds: , default: 1e-6 <code>None</code> <code>coordinates_type</code> <code>str | None</code> <p>Type of coordinate system (default is \"euclidean\"). Type: str, values: [\"euclidean\", \"geographic\"], default: \"euclidean\"</p> <code>None</code> <code>variogram_model</code> <code>str | None</code> <p>Variogram model to use (default is \"linear\"). Type: str, values: [\"linear\", \"power\", \"gaussian\", \"spherical\", \"exponential\"], default: \"linear\"</p> <code>None</code> <code>pseudo_inv</code> <code>bool</code> <p>Whether to use pseudo-inverse for matrix operations (default is False).</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>SparseDataset</code> <p>The sparse dataset to reconstruct.</p> <code>domain</code> <code>Domain</code> <p>The target domain for reconstruction.</p> <code>pykrige_kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to pykrige.</p> <code>backend</code> <code>Literal['vectorized', 'loop'] | None</code> <p>The backend to use for kriging.</p> <code>_MAX_VECTORIZED_SIZE</code> <code>ClassVar[int]</code> <p>The maximum size for vectorized kriging. If the dataset is larger than this size, loop kriging will be used (if <code>backend</code> was not specified)</p> Notes <p>Hyperparameters for optimization:     - nlags: int in (4, 20), default=6     - anisotropy_scaling: float in (1e-6, 5.0), default=1e-6     - coordinates_type: str in [\"euclidean\", \"geographic\"], default=\"euclidean\"     - variogram_model: str in [\"linear\", \"power\", \"gaussian\", \"spherical\", \"exponential\"], default=\"linear\"</p>"},{"location":"api/#climatrix.reconstruct.kriging.OrdinaryKrigingReconstructor.reconstruct","title":"<code>reconstruct()</code>","text":"<p>Perform Ordinary Kriging reconstruction of the dataset.</p> <p>Returns:</p> Type Description <code>BaseClimatrixDataset</code> <p>The dataset reconstructed on the target domain.</p> Notes <ul> <li>The backend is chosen based on the size of the dataset. If the dataset is larger than the maximum size, the loop backend is used.</li> </ul>"},{"location":"api/#climatrix.reconstruct.siren.siren.SIRENReconstructor","title":"<code>climatrix.reconstruct.siren.siren.SIRENReconstructor</code>","text":"<p>               Bases: <code>BaseReconstructor</code></p> <p>A reconstructor that uses SIREN to reconstruct fields.</p> <p>SIREN (Sinusoidal Representation Networks) uses sinusoidal activation functions to learn continuous implicit neural representations of spatial fields from sparse observations.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>BaseClimatrixDataset</code> <p>Source dataset to reconstruct from.</p> required <code>target_domain</code> <code>Domain</code> <p>Target domain to reconstruct onto.</p> required <code>on_surface_points</code> <code>int</code> <p>Number of points to sample on the surface for training.</p> <code>1024</code> <code>hidden_features</code> <code>int</code> <p>Number of features in each hidden layer.</p> <code>256</code> <code>hidden_layers</code> <code>int</code> <p>Number of hidden layers in the SIREN model.</p> <code>4</code> <code>omega_0</code> <code>float</code> <p>Frequency multiplier for the first layer.</p> <code>30.0</code> <code>omega_hidden</code> <code>float</code> <p>Frequency multiplier for hidden layers.</p> <code>30.0</code> <code>lr</code> <code>float</code> <p>Learning rate for the optimizer. Type: float, bounds: , default: 1e-3 <code>1e-4</code> <code>batch_size</code> <code>int</code> <p>Batch size for training. Type: int, bounds: , default: 256 <code>256</code> <code>num_epochs</code> <code>int</code> <p>Number of epochs to train for. Type: int, bounds: , default: 5_000 <code>100</code> <code>hidden_dim</code> <code>int</code> <p>Hidden layer dimensions. Type: int, bounds: , default: 256 <code>256</code> <code>num_layers</code> <code>int</code> <p>Number of hidden layers. Type: int, bounds: , default: 4 <code>4</code> <code>num_workers</code> <code>int</code> <p>Number of worker processes for the dataloader.</p> <code>0</code> <code>device</code> <code>str</code> <p>Device to run the model on (\"cuda\" or \"cpu\").</p> <code>\"cuda\"</code> <code>gradient_clipping_value</code> <code>float or None</code> <p>Value for gradient clipping (None to disable). Type: float, bounds: , default: 1.0 <code>None</code> <code>checkpoint</code> <code>str or PathLike or Path or None</code> <p>Path to save/load model checkpoint from.</p> <code>None</code> <code>sdf_loss_weight</code> <code>float</code> <p>Weight for the SDF constraint loss.</p> <code>3000.0</code> <code>inter_loss_weight</code> <code>float</code> <p>Weight for the interpolation consistency loss.</p> <code>100.0</code> <code>normal_loss_weight</code> <code>float</code> <p>Weight for the surface normal loss.</p> <code>100.0</code> <code>grad_loss_weight</code> <code>float</code> <p>Weight for the gradient regularization loss.</p> <code>50.0</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If trying to use SIREN with a dynamic dataset.</p> Notes <p>Hyperparameters for optimization:     - lr: float in (1e-5, 1e-2), default=1e-3     - batch_size: int in (64, 1024), default=256     - num_epochs: int in (100, 10_000), default=5_000     - hidden_dim: int in (128, 512), default=256     - num_layers: int in (3, 8), default=4     - gradient_clipping_value: float in (0.1, 10.0), default=1.0</p>"},{"location":"api/#climatrix.reconstruct.siren.siren.SIRENReconstructor.configure_optimizer","title":"<code>configure_optimizer(model)</code>","text":"<p>Configure the optimizer for the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Module</code> <p>The model to optimize.</p> required <p>Returns:</p> Type Description <code>Optimizer</code> <p>Configured Adam optimizer.</p>"},{"location":"api/#climatrix.reconstruct.siren.siren.SIRENReconstructor.init_model","title":"<code>init_model()</code>","text":"<p>Initialize the 3D SIREN model.</p> <p>Returns:</p> Type Description <code>Module</code> <p>Initialized SIREN model on the appropriate device.</p>"},{"location":"api/#climatrix.reconstruct.siren.siren.SIRENReconstructor.reconstruct","title":"<code>reconstruct()</code>","text":"<p>Train (if necessary) and use a SIREN model to reconstruct the field.</p> <p>This method is the main entry point for using the SIREN reconstructor. It will train a new model if no checkpoint was loaded, and then use the model to reconstruct the field on the target domain.</p> <p>Returns:</p> Type Description <code>BaseClimatrixDataset</code> <p>A dataset containing the reconstructed field.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If required dependencies are not installed.</p>"},{"location":"api/#evaluation","title":"\u2696\ufe0f Evaluation","text":""},{"location":"api/#climatrix.comparison.Comparison","title":"<code>climatrix.comparison.Comparison</code>","text":"<p>Class for comparing two datasets (dense or sparse).</p> <p>For sparse domains, uses nearest neighbor matching with optional distance thresholds to find corresponding observations.</p> <p>Attributes:</p> Name Type Description <code>predicted_dataset</code> <code>BaseClimatrixDataset</code> <p>The predicted/source dataset.</p> <code>true_dataset</code> <code>BaseClimatrixDataset</code> <p>The true/target dataset.</p> <code>diff</code> <code>BaseClimatrixDataset</code> <p>The difference between the predicted and true datasets.</p> <code>distance_threshold</code> <code>(float, optional)</code> <p>Maximum distance for point correspondence in sparse domains.</p> <p>Parameters:</p> Name Type Description Default <code>predicted_dataset</code> <code>BaseClimatrixDataset</code> <p>The predicted/source dataset.</p> required <code>true_dataset</code> <code>BaseClimatrixDataset</code> <p>The true/target dataset.</p> required <code>map_nan_from_source</code> <code>bool</code> <p>If True, the NaN values from the source dataset will be mapped to the target dataset. If False, the NaN values from the target dataset will be used. Default is None, which means <code>False</code> for sparse datasets and <code>True</code> for dense datasets.</p> <code>None</code> <code>distance_threshold</code> <code>float</code> <p>For sparse domains, maximum distance threshold for considering points as corresponding. If None, closest points are always matched. Only used when both datasets have sparse domains.</p> <code>None</code>"},{"location":"api/#climatrix.comparison.Comparison.plot_diff","title":"<code>plot_diff(title=None, target=None, show=False, ax=None, **kwargs)</code>","text":"<p>Plot the difference between the source and target datasets.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title of the plot. If not provided, the name of the dataset will be used. If the dataset has no name, \"Climatrix Dataset\" will be used.</p> <code>None</code> <code>target</code> <code>str, os.PathLike, Path, or None</code> <p>Path to save the plot. If not provided, the plot will not be saved.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Whether to show the plot. Default is False.</p> <code>False</code> <code>ax</code> <code>Axes</code> <p>Axes to plot on. If not provided, a new figure and axes will be created.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments to pass to the plotting function.</p> <ul> <li><code>figsize</code>: tuple, optional     Size of the figure. Default is (12, 6).</li> <li><code>vmin</code>: float, optional     Minimum value for the color scale. Default is None.</li> <li><code>vmax</code>: float, optional     Maximum value for the color scale. Default is None.</li> <li><code>cmap</code>: str, optional     Colormap to use for the plot. Default is \"seismic\".</li> <li><code>size</code>: int, optional     Size of the points for sparse datasets. Default is 10.</li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib axes containing the plot of the difference.</p>"},{"location":"api/#climatrix.comparison.Comparison.plot_signed_diff_hist","title":"<code>plot_signed_diff_hist(ax=None, n_bins=50, limits=None, label=None, alpha=1.0)</code>","text":"<p>Plot the histogram of signed difference between datasets.</p> <p>The signed difference is a dataset where positive values represent areas where the source dataset is larger than the target dataset and negative values represent areas where the source dataset is smaller than the target dataset.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The matplotlib axes on which to plot the histogram. If None, a new set of axes will be created.</p> <code>None</code> <code>n_bins</code> <code>int</code> <p>The number of bins to use in the histogram (default is 50).</p> <code>50</code> <code>limits</code> <code>tuple[float]</code> <p>The limits of values to include in the histogram (default is None).</p> <code>None</code> <p>Returns:</p> Type Description <code>Axes</code> <p>The matplotlib axes containing the plot of the signed difference.</p>"},{"location":"api/#climatrix.comparison.Comparison.compute_rmse","title":"<code>compute_rmse()</code>","text":"<p>Compute the RMSE between the source and target datasets.</p> <p>Returns:</p> Type Description <code>float</code> <p>The RMSE between the source and target datasets.</p>"},{"location":"api/#climatrix.comparison.Comparison.compute_mae","title":"<code>compute_mae()</code>","text":"<p>Compute the MAE between the source and target datasets.</p> <p>Returns:</p> Type Description <code>float</code> <p>The mean absolute error between the source and target datasets.</p>"},{"location":"api/#climatrix.comparison.Comparison.compute_r2","title":"<code>compute_r2()</code>","text":"<p>Compute the R^2 between the source and target datasets.</p> <p>Returns:</p> Type Description <code>float</code> <p>The R^2 between the source and target datasets.</p>"},{"location":"api/#climatrix.comparison.Comparison.compute_max_abs_error","title":"<code>compute_max_abs_error()</code>","text":"<p>Compute the maximum absolute error between datasets.</p> <p>Returns:</p> Type Description <code>float</code> <p>The maximum absolute error between the source and target datasets.</p>"},{"location":"api/#climatrix.comparison.Comparison.compute_report","title":"<code>compute_report()</code>","text":""},{"location":"api/#climatrix.comparison.Comparison.save_report","title":"<code>save_report(target_dir)</code>","text":"<p>Save a report of the comparison between passed datasets.</p> <p>This method will create a directory at the specified path and save a report of the comparison between the source and target datasets in that directory. The report will include plots of the difference and signed difference between the datasets, as well as a csv file with metrics such as the RMSE, MAE, and maximum absolute error.</p> <p>Parameters:</p> Name Type Description Default <code>target_dir</code> <code>str | PathLike | Path</code> <p>The path to the directory where the report should be saved.</p> required"},{"location":"api/#hyperparameter-optimization","title":"\ud83d\udd27 Hyperparameter Optimization","text":"<p>Climatrix provides automated hyperparameter optimization for all reconstruction methods using Bayesian optimization.</p>"},{"location":"api/#installation","title":"Installation","text":"<p>To use hyperparameter optimization, install climatrix with the optimization extras:</p> <pre><code>pip install climatrix[optim]\n</code></pre> <p>This installs the required <code>bayesian-optimization</code> package dependency.</p>"},{"location":"api/#hparamfinder","title":"HParamFinder","text":""},{"location":"api/#climatrix.optim.HParamFinder","title":"<code>climatrix.optim.HParamFinder</code>","text":"<p>Bayesian hyperparameter optimization for reconstruction methods.</p> <p>This class uses Bayesian optimization to find optimal hyperparameters for various reconstruction methods.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Reconstruction method to optimize.</p> required <code>train_dset</code> <code>BaseClimatrixDataset</code> <p>Training dataset used for optimization.</p> required <code>val_dset</code> <code>BaseClimatrixDataset</code> <p>Validation dataset used for optimization.</p> required <code>metric</code> <code>str</code> <p>Evaluation metric to optimize. Default is \"mae\". Supported metrics: \"mae\", \"mse\", \"rmse\".</p> <code>'mae'</code> <code>exclude</code> <code>str or Collection[str]</code> <p>Parameter(s) to exclude from optimization.</p> <code>None</code> <code>include</code> <code>str or Collection[str]</code> <p>Parameter(s) to include in optimization. If specified, only these parameters will be optimized.</p> <code>None</code> <code>n_iters</code> <code>int</code> <p>Total number of optimization iterations. Default is 100.</p> <code>100</code> <code>bounds</code> <code>dict</code> <p>Custom parameter bounds. Overrides default bounds for the method.</p> <code>None</code> <code>random_seed</code> <code>int</code> <p>Random seed for reproducible optimization. Default is 42.</p> <code>42</code> <code>reconstructor_kwargs</code> <code>dict</code> <p>Additional keyword arguments for the reconstructor. The optimizable parameters will be overridden by the optimizer.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>train_dset</code> <code>BaseClimatrixDataset</code> <p>Training dataset.</p> <code>val_dset</code> <code>BaseClimatrixDataset</code> <p>Validation dataset.</p> <code>metric</code> <code>MetricType</code> <p>Evaluation metric.</p> <code>method</code> <code>str</code> <p>Reconstruction method.</p> <code>bounds</code> <code>dict</code> <p>Parameter bounds for optimization.</p> <code>n_iter</code> <code>int</code> <p>Number of optimization iterations.</p> <code>random_seed</code> <code>int</code> <p>Random seed for optimization.</p> <code>verbose</code> <code>int</code> <p>Verbosity level for logging (0 - silent, 1 - info, 2 - debug).</p> <code>n_startup_trials</code> <code>int</code> <p>Number of startup trials for the optimizer.</p> <code>n_warmup_steps</code> <code>int</code> <p>Number of warmup steps before starting optimization.</p> <code>reconstructor_kwargs</code> <code>dict</code> <p>Additional keyword arguments for the reconstructor.</p> <code>result</code> <code>dict</code> <p>Dictionary containing optimization results: - 'best_params': Best hyperparameters found (with correct types) - 'best_score': Best score achieved (negative metric value) - 'metric_name': Name of the optimized metric - 'method': Reconstruction method used - 'n_trials': Total number of trials performed</p>"},{"location":"api/#climatrix.optim.HParamFinder.optimize","title":"<code>optimize()</code>","text":"<p>Run Bayesian optimization to find optimal hyperparameters.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing: - 'best_params': Best hyperparameters found (with correct types) - 'best_score': Best score achieved (negative metric value) - 'history': Optimization history - 'metric_name': Name of the optimized metric - 'method': Reconstruction method used</p>"},{"location":"api/#supported-methods-and-parameters","title":"Supported Methods and Parameters","text":"<p>The hyperparameter optimizer supports all reconstruction methods available in Climatrix. For detailed information about each method's hyperparameters, including their types, bounds, and default values, see the Reference documentation for each reconstruction class:</p> <ul> <li>IDWReconstructor - Inverse Distance Weighting</li> <li>OrdinaryKrigingReconstructor - Ordinary Kriging  </li> <li>SiNETReconstructor - Spatial Interpolation NET</li> <li>SIRENReconstructor - Sinusoidal INR   </li> </ul>"},{"location":"cli/","title":"\ud83e\uddd1\u200d\ud83d\udcbb\ufe0f Climatrix Command Line Interface (CLI)","text":"Warning <p>The <code>climatrix</code> CLI is currently experimental and offers limited functionality.</p> <p>The <code>climatrix</code> library includes a command-line interface (CLI) to help you:</p> <ul> <li>\u2705 Download datasets from the CDS API</li> </ul>"},{"location":"cli/#dataset-features","title":"\ud83d\udce6 Dataset Features","text":"<p>Climatrix simplifies access to the (Copernicus Climate Data Store (CDS))[https://cds.climate.copernicus.eu/] API through an easy-to-use command-line interface.</p> Info <p>To access CDS datasets, you must:</p> <ul> <li> <p>Register on the CDS website</p> </li> <li> <p>Agree to the license terms</p> </li> <li> <p>Configure climatrix with your CDS API credentials</p> </li> </ul>"},{"location":"cli/#supported-datasets","title":"\u2705 Supported Datasets","text":"<p>Currently, Climatrix supports downloading the following datasets:</p> <ol> <li>ERA5-Land Reanalysis</li> <li>E-OBS</li> </ol>"},{"location":"cli/#list-available-datasets","title":"\ud83d\uddc2 List Available Datasets","text":"<p>To see the list of available datasets:</p> <pre><code>cm dataset list\n</code></pre> <p>to get the list of available datasets.</p>"},{"location":"cli/#configure-credentials","title":"\u2699\ufe0f Configure credentials","text":"<p>Before downloading data, configure the related datastore:</p> Note <p>At the moment, we support only access to (Copernicus Climate Data Store (CDS))[https://cds.climate.copernicus.eu/]</p> <pre><code>cm dataset config cds\n</code></pre> <p>Follow the prompts to enter your CDS API key and URL (if the default one is not suitable).</p>"},{"location":"cli/#download-a-dataset","title":"\u2b07\ufe0f Download a Dataset","text":"<p>To download a dataset, use:</p> <pre><code>cm dataset download [dataset-name] [options]\n</code></pre> <p>Replace [dataset-name] with one of the supported datasets (see (Supported Datasets)[#supported-datasets]).</p> Option Short name Description <code>--year</code> <code>-y</code> Year of data to download <code>--month</code> <code>-m</code> Month of data to download <code>--day</code> <code>-d</code> Day of data to download <code>--hour</code> <code>-h</code> Hour of data to download <code>--target</code> <code>-t</code> Path to save the downloaded dataset <code>--variable</code> <code>-v</code> Variables to download Download temperature and surface pressure <pre><code>cm dataset download era5-land -y 2024 -m 10 -d 10 -h 15 -v 2m_temperature -v surface_pressure -t ./test.nc\n</code></pre>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started with <code>climatrix</code>","text":"<p>Welcome to climatrix \u2013 a Python library designed for efficient sampling and reconstruction of climate datasets. This guide will help you set up and start using <code>climatrix</code> effectively.</p>"},{"location":"getting_started/#installation","title":"\ud83d\udce6 Installation","text":""},{"location":"getting_started/#prerequisites","title":"\ud83d\udd27 Prerequisites","text":"<p>Ensure you have the following installed:</p> <ul> <li>Python 3.12 or higher</li> <li>pip (Python package installer)</li> </ul>"},{"location":"getting_started/#installing-climatrix","title":"\ud83d\udee0\ufe0f Installing <code>climatrix</code>","text":"<p>You can install <code>climatrix</code> directly from GitHub:</p> <pre><code>pip install git+https://github.com/jamesWalczak/climatrix.git\n</code></pre> Climatrix is already available on PyPI <p>The project can be downloaded with <code>pip install climatrix</code>.</p>"},{"location":"getting_started/#optional-dependencies","title":"Optional Dependencies","text":"<p>For hyperparameter optimization functionality, install with the <code>optim</code> extra:</p> <pre><code>pip install climatrix[optim]\n</code></pre> <p>This enables automated hyperparameter tuning using Bayesian optimization.</p>"},{"location":"getting_started/#verifying-the-installation","title":"\ud83e\uddea Verifying the Installation","text":"<p>To confirm that <code>climatrix</code> is installed correctly, run the following in your Python environment:</p> <pre><code>import climatrix as cm\n\nprint(cm.__version__)\n</code></pre>"},{"location":"getting_started/#exploring-climatrix","title":"\ud83d\udd0d Exploring <code>climatrix</code>","text":"<p>The core functionality of <code>climatrix</code> revolves around the <code>BaseClimatrixDataset</code> and <code>Domain</code> classes, which provides methods for:</p> <ul> <li>Accessing spatio-temporal axes</li> <li>Subsetting datasets based on geographic bounds,</li> <li>Selecting time,</li> <li>Sampling data using uniform or normal distributions,</li> <li>Reconstructing datasets from samples,</li> <li>Plotting data for visualization.</li> </ul>"},{"location":"getting_started/#creating-baseclimatrixdataset","title":"Creating <code>BaseClimatrixDataset</code>","text":"<p>You can create <code>BaseClimatrixDataset</code> directly, by passing <code>xarray.DataArray</code> or <code>xarray.Daaset</code> to the initializer:</p> Note <p>In the current version, <code>climatrix</code> supports only static (single-element or no time dimension) and single-variable datasets.</p> <p>It means, <code>BaseClimatrixDataset</code> can be created based on <code>xarray.DataArray</code> or single-variable <code>xarray.Dataset</code>.</p> <pre><code>import climatrix as cm\n\ndset = cm.BaseClimatrixDataset(xarray_dataset)\n</code></pre> <p>but <code>climatrix</code> was implemented as <code>xarray</code> accessor, so there is more convenient way to create <code>BaseClimatrixDataset</code>:</p> <pre><code>import climatrix as cm # (1)!\n\ndset = xarray_dataset.cm\n</code></pre> <ol> <li>Even though, we don't use <code>climatrix</code> explicitly, we need to import climatrix to make <code>xarray</code> accessor visible.</li> </ol> Warning <p>When using <code>climatrix</code> as accessor, remember to import <code>climatrix</code> first!</p>"},{"location":"getting_started/#creating-domains-with-from_axes","title":"Creating Domains with <code>from_axes()</code>","text":"<p>The <code>Domain</code> class provides a flexible builder pattern for creating domains with multiple axis types using the <code>from_axes()</code> method:</p> <pre><code>from climatrix.dataset.domain import Domain\n\n# Create a sparse domain with vertical, latitude, longitude, and time\ndomain = (Domain.from_axes()\n          .vertical(depth=slice(10, 100, 10))\n          .lat(latitude=[1, 2, 3, 4])\n          .lon(longitude=[5, 6, 7, 8])\n          .time(time=['2020-01-01', '2020-01-02'])\n          .sparse())\n\n# Create a dense domain with custom axis names  \ndomain = (Domain.from_axes()\n          .vertical(pressure=[1000, 850, 500])\n          .lat(lat=slice(-90, 90, 1))\n          .lon(lon=slice(-180, 180, 1))\n          .dense())\n</code></pre> Flexible Axis Configuration <p>The builder pattern supports:</p> <ul> <li>Custom axis names: Use any parameter name (e.g., <code>depth=...</code>, <code>pressure=...</code>)</li> <li>Multiple data types: Accepts slices, lists, and numpy arrays</li> <li>Method chaining: Configure multiple axes in a fluent interface</li> <li>Both domain types: Create sparse or dense domains with <code>.sparse()</code> or <code>.dense()</code></li> </ul> Vertical Axis Independence <p>Currently, vertical axes can be independent dimensions. In future versions, vertical coordinates will support sparse coordinate structure like lat/lon (e.g., <code>lat(point)</code>, <code>lon(point)</code>, <code>vertical(point)</code>).</p> <p>For simple lat/lon domains, you can still use the traditional approach:</p> <pre><code># Traditional method for lat/lon only\ndomain = Domain.from_lat_lon(\n    lat=slice(-90, 90, 1), \n    lon=slice(-180, 180, 1), \n    kind=\"dense\"\n)\n</code></pre>"},{"location":"getting_started/#accessing-spatio-temporal-axes","title":"Accessing spatio-temporal axes","text":"<p>By using Climatrix, you can easily acces spatio temporal axis. </p> Info <p>You don't need to know the name of axis (<code>lat</code>, <code>latitude</code> or anything else), Climatrix automatically finds proper axis by matching regular expressions.</p> <p>All predefined axis are available via <code>Axis</code> enum class.</p> <p>To access latitude name, just use:</p> <pre><code>xarray_dataset.cm.latitude.name\n</code></pre> <p>and to access values, use:</p> <pre><code>xarray_dataset.cm.latitude.values\n</code></pre> <p>Below, you can find available attributes:</p> Attribute Meaning <code>latitude</code> <code>Axis</code> corresponding to <code>AxisType.LATITUDE</code> for the dataset <code>longitude</code> <code>Axis</code> corresponding to <code>AxisType.LONGITUDE</code> for the dataset <code>time</code> <code>Axis</code> corresponding to <code>AxisType.TIME</code> for the dataset <code>point</code> <code>Axis</code> corresponding to <code>AxisType.POINT</code> for the dataset <code>vertical</code> <code>Axis</code> corresponding to <code>AxisType.VERTICAL</code> for the dataset"},{"location":"getting_started/#subsetting-dataset-by-geographical-coordinates","title":"Subsetting dataset by geographical coordinates","text":"<p>Climatrix facilitates subsetting region based on bounding box. To select Europe, just use the following command:</p> <pre><code>europe = xarray_dataset.cm.subset(north=71, south=36, west=-24, east=35)\n</code></pre> Warning <p>If you attempt to select region not aligned with the dataset longitude convention, Climatrix will inform you about it and ask for explicit update of convention.</p> Tip <p>With Climatrix chaning convention is easy!</p> <p>To switch to signed longitude convention (\\(\\lambda \\in [-180, 180]\\)) use <code>to_signed_longitude</code> method.</p> <pre><code>europe = xarray_dataset.cm.to_signed_longitude()\n</code></pre> <p>To switch to positive-only longitude convention (\\(\\lambda \\in [0, 360]\\)), use <code>to_positive_longitude</code> method.</p> <pre><code>europe = xarray_dataset.cm.to_positive_longitude()\n</code></pre>"},{"location":"getting_started/#selecting-time","title":"Selecting time","text":"<p>You can select time instants by integer (indices on time axis):</p> <pre><code>xr_dset = xr.tutorial.open_dataset(\"air_temperature\")\nsingle_time_instant = xr_dset.cm.itime(0)\nseveral_time_instants = xr_dset.cm.itime([0, 100])\nseveral_time_instants = xr_dset.cm.itime(slice(5, 200))\n</code></pre> <p>or by date:</p> <pre><code>xr_dset = xr.tutorial.open_dataset(\"air_temperature\")\nsingle_time_instant = xr_dset.cm.time(\"2013-02-10\")\nseveral_time_instants = xr_dset.cm.time([\"2013-02-10\", \"2013-02-12\"])\nseveral_time_instants = xr_dset.cm.time(slice(\"2013-02-10\", \"2013-02-12\"))\n</code></pre> Tip <p>You can also use <code>sel</code> or <code>isel</code> method with <code>AxisType.TIME</code>.</p>"},{"location":"getting_started/#sampling-data","title":"Sampling data","text":"<p>In Climatrix there are following sampling methods implemented:</p> Sampling Description uniform data are randomly (uniformly) sampled from the entire spatial domain normal data are randomly (following normal distribution) sampled around the defined center point (locaion) <p>To sample \\(10\\%\\) (\\(0.1\\)) of spatial points, use:</p> <pre><code>import xarray as xr\nimport climatrix as cm\n\nxr_dset = xr.tutorial.open_dataset(\"air_temperature\") # (1)!\ndset = xr_dset.cm.itime(0) # (2)!\n\nsparse = dset.sample_uniform(portion=0.1)\n\nsparse.plot(title=\"Uniform Sampling (10%)\")\n</code></pre> <ol> <li>We will use tutorial dataset from <code>xarray</code>. To use it, some extra packages might be required.</li> <li>We select just a first time instant (here, 2013-01-01T00:00)</li> </ol> Tip <p>If you need exact number of resulting points, use <code>number</code> parameter. It is valid also for <code>sample_normal</code></p> Note <p>For sampling method, you can specify NaN-policy (<code>nan</code> parameter). There are three options:</p> <ul> <li><code>ignore</code> - NaN values will be sampled,</li> <li><code>raise</code>  - error will be raised if any NaN valu will be found</li> <li><code>resample</code> - attempts to return not-NaN values</li> </ul>"},{"location":"getting_started/#reconstructing","title":"Reconstructing","text":"<p>The main functionality of the accessor is to ease data reconstruction. You can reconstruct dense domain from a sparse one, or sparse from another sparse.</p> <pre><code>import xarray as xr\nimport climatrix as cm\n\nxr_dset = xr.tutorial.open_dataset(\"air_temperature\") \ndset = xr_dset.cm.itime(0)\nsparse = dset.sample_uniform(portion=0.1) # (1)!\n\ndense = sparse.reconstruct(dset.domain, method=\"idw\") # (2)! \ndense.plot(title=\"Reconstructed dataset\")\n</code></pre> <ol> <li>First, we need to sample some sparse dataset.</li> <li>Note, we use domain of <code>dset</code> not <code>xr_dset.cm</code>. We want to reconstruct to the original domain after time subsetting</li> </ol> Note <p>You can pass extra reconstructor-specific arguments as the last (<code>recon_kwargs</code>) argument of the <code>reconstruct</code> method. To find definitions of these extra arguments, refer to Reconstruction section in API reference.</p>"},{"location":"getting_started/#hyperparameter-optimization","title":"Hyperparameter Optimization","text":"<p>For optimal reconstruction results, you can use automated hyperparameter optimization:</p> <pre><code>from climatrix.optim import HParamFinder\n\n# Split your data for optimization\ntrain_dset = dset.sample_uniform(portion=0.7)  # Training data\nval_dset = dset.sample_uniform(portion=0.2)    # Validation data\n\n# Optimize IDW parameters\nfinder = HParamFinder(train_dset, val_dset, method=\"idw\")\nresult = finder.optimize()\n\nprint(f\"Best parameters: {result['best_params']}\")\nprint(f\"Best MAE score: {result['best_score']}\")\n\n# Use optimized parameters for reconstruction\noptimized_reconstruction = sparse.reconstruct(\n    dset.domain, \n    method=\"idw\",\n    **result['best_params']\n)\n</code></pre> Note <p>Hyperparameter optimization requires the <code>optim</code> extra: <code>pip install climatrix[optim]</code></p>"},{"location":"getting_started/#plotting","title":"Plotting","text":"<p>To plot dataset (for either dense or sparse domain), just use <code>plot</code> method:</p> <pre><code>dset = xr_dset.cm.itime(0).plot()\n</code></pre> Warning <p>At the moment, plotting is enabled only for static datasets. Remember to select a single time instant before plotting.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Jakub Walczak</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"tutorial/","title":"\ud83d\udc4b Welcome to the <code>climatrix</code> Tutorial","text":"<p>This tutorial will walk you through some typical use cases showing how <code>climatrix</code> makes managing climate data easier.</p> <p>We'll simulate sparse meteorological observations spread across Europe.</p>"},{"location":"tutorial/#step-a-configure-access-to-cds","title":"\ud83d\udee0\ufe0f Step A: Configure Access to CDS","text":"Warning <p>If you already have a <code>~/.cdsapirc</code> file, you can skip this step.</p> <p>To configure access to the CDS (Climate Data Store), run:</p> <pre><code>cm dataset config cds\n</code></pre> <p>To configure CDS store.</p>"},{"location":"tutorial/#step-b-download-era5-land-reanalysis-data","title":"\ud83d\udce5 Step B: Download ERA5-Land Reanalysis Data","text":"<p>We'll use the ERA5-Land global reanalysis product. To download it, run:</p> <pre><code>cm dataset download era5-land --year 2018 --month 10 --day 12 --target ./era5-land.nc\n</code></pre> Note <p>Downloading data can take a few minutes\u2014please be patient.</p>"},{"location":"tutorial/#step-c-open-the-dataset","title":"\ud83d\udcc2 Step C: Open the Dataset","text":"<p>We\u2019ll open the dataset using the <code>climatrix</code> accessor:</p> <pre><code>import xarray as xr\nimport climatrix as cm # (1)!\n\ndset = xr.open_dataset(\"./era5-land.nc\").cm\n</code></pre> <ol> <li>Even though we're not using climatrix directly, we must import it to enable the <code>climatrix</code> xarray accessor to available.</li> </ol>"},{"location":"tutorial/#step-d-shift-to-signed-longitude-convention","title":"\ud83c\udf0d Step D: Shift to Signed Longitude Convention","text":"<p>ERA5-Land uses the positive longitude convention  (\\(\\lambda \\in [0, 360]\\)). To make it easier to work with Europe, we\u2019ll convert it to the signed convention (\\(\\lambda \\in [-180, 180]\\)).</p> <pre><code>dset = dset.to_signed_longitude()\n</code></pre> Warning <p>Changing longitude convention on a large dataset can be time and memory intensive.</p>"},{"location":"tutorial/#step-e-subset-to-europe","title":"\ud83c\udf10 Step E: Subset to Europe","text":"<p>We'll now extract a region covering Europe:</p> <pre><code>europe = dset.subset(north=71, south=36, west=-24, east=35)\n</code></pre>"},{"location":"tutorial/#step-f-select-a-single-time-instant","title":"\u23f1\ufe0f Step F: Select a Single Time Instant","text":"Note <p><code>cliamtrix</code> currently doesn\u2019t support plotting dynamic datasets. Let\u2019s select a single timestamp.</p> <p>To select a single time instant, let's use:</p> <p><pre><code>europe = europe.time(\"2018-10-12T04:00:00\")\neurope.plot()\n</code></pre> </p> Tip <p>You can also pass Python <code>datetime</code> object to the <code>time</code> method.</p>"},{"location":"tutorial/#step-g-sample-data-around-warsaw","title":"\ud83c\udfaf Step G: Sample Data Around Warsaw","text":"<p>We'll create a sparse sample of data points around Warsaw, using a normal distribution:</p> <pre><code>WARSAW = (21.017532, 52.237049)\nsparse = europe.sample_normal(number=5_00, center_point=WARSAW, sigma=1.5)\n</code></pre> Tip <p>You can use the <code>portion</code> argument instead of <code>number</code> to sample a fraction of the dataset (e.g., 50%).</p>"},{"location":"tutorial/#step-h-plot-the-sparse-observations","title":"\ud83d\uddbc\ufe0f Step H: Plot the Sparse Observations","text":"<p>Now we can plot the output:</p> <pre><code>sparse.plot()\n</code></pre> <p></p> Warning <p>Plotting requires downloading coastline and border data, so it may take longer the first time.</p>"},{"location":"tutorial/#step-h1-creating-custom-domains-optional","title":"\ud83c\udfd7\ufe0f Step H.1: Creating Custom Domains (Optional)","text":"<p>You can create custom domains with multiple axis types using the builder pattern. This is especially useful when working with vertical levels or custom time series:</p> <pre><code>from climatrix.dataset.domain import Domain\n\n# Create a domain with vertical levels around Warsaw\ncustom_domain = (Domain.from_axes()\n                 .vertical(pressure=[1000, 850, 700, 500])  # (1)!\n                 .lat(latitude=[51.5, 52.0, 52.5])\n                 .lon(longitude=[20.5, 21.0, 21.5]) \n                 .time(time=['2018-10-12T00:00', '2018-10-12T06:00'])\n                 .sparse())  # (2)!\n\nprint(f\"Custom domain size: {custom_domain.size}\")\nprint(f\"Has vertical axis: {custom_domain.has_axis('vertical')}\")\n</code></pre> <ol> <li>Define pressure levels as the vertical coordinate</li> <li>Create as sparse domain - vertical and time are independent dimensions</li> </ol> Domain Builder Features <p>The <code>from_axes()</code> builder supports:</p> <ul> <li>Vertical axes: <code>pressure</code>, <code>depth</code>, <code>level</code>, etc.</li> <li>Time axes: Various time coordinate names</li> <li>Custom names: Any parameter name for each axis type</li> <li>Flexible inputs: Slices, lists, or numpy arrays</li> </ul>"},{"location":"tutorial/#step-i-reconstruct-using-idw","title":"\ud83d\udd01 Step I: Reconstruct Using IDW","text":"<p>We\u2019ll reconstruct a dense field from the sparse data using Inverse Distance Weighting (IDW):</p> <pre><code>idw = sparse.reconstruct(europe.domain, method=\"idw\") # (1)!\nidw.plot()\n</code></pre> <ol> <li>We want to reconstruct data for all Europe (<code>europe.domain</code>).</li> </ol> <p></p> Note <p>Note that we reconstructed the data for the entire Europe. Those visible artifacts are the result of too few samples concentrated around Warsaw. They are not representative for the entire Europe. </p>"},{"location":"tutorial/#step-j-compare-with-original-data","title":"\ud83d\udcca Step J: Compare with Original Data","text":"<p>We'll use <code>Comparison</code> object to visualize the differences.</p> <pre><code>import matplotlib.pyplot as plt # (1)!\n\ncmp = cm.Comparison(europe, idw) \ncmp.plot_diff()\ncmp.plot_signed_diff_hist()\n\nplt.show()\n</code></pre> <ol> <li>We explicitly import <code>matplotlib</code> to be able to run <code>plt.show()</code> and display figures. </li> </ol> <p> </p>"},{"location":"tutorial/#step-k-optimize-hyperparameters","title":"\ud83c\udfaf Step K: Optimize Hyperparameters","text":"<p>To improve reconstruction quality, let's optimize the IDW hyperparameters. We'll split our sparse data for training and validation:</p> <pre><code>from climatrix.optim import HParamFinder\n\n# Create training and validation datasets\ntrain_sparse = europe.sample_normal(number=300, center_point=WARSAW, sigma=1.5) # (1)!\nval_sparse = europe.sample_normal(number=200, center_point=WARSAW, sigma=1.5)   # (2)!\n\n# Find optimal hyperparameters\nfinder = HParamFinder(train_sparse, val_sparse, method=\"idw\", n_iters=20) # (3)!\nresult = finder.optimize()\n\nprint(f\"Best parameters: {result['best_params']}\")\nprint(f\"Best MAE score: {result['best_score']}\")\n</code></pre> <ol> <li>Training data - used to fit the hyperparameter optimization</li> <li>Validation data - used to evaluate parameter combinations  </li> <li>Using fewer iterations for this tutorial example</li> </ol>"},{"location":"tutorial/#step-l-apply-optimized-parameters","title":"\ud83d\ude80 Step L: Apply Optimized Parameters","text":"<p>Now let's reconstruct using the optimized parameters:</p> <pre><code># Reconstruct with optimized parameters\noptimized_idw = sparse.reconstruct(\n    europe.domain, \n    method=\"idw\", \n    **result['best_params'] # (1)!\n)\n\n# Compare optimized vs default reconstruction\noptimized_cmp = cm.Comparison(europe, optimized_idw)\ndefault_cmp = cm.Comparison(europe, idw)\n\nprint(f\"Default IDW RMSE: {default_cmp.compute_rmse():.4f}\")\nprint(f\"Optimized IDW RMSE: {optimized_cmp.compute_rmse():.4f}\")\n\noptimized_idw.plot(title=\"Optimized IDW Reconstruction\")\n</code></pre> <ol> <li>Apply the best parameters found by the optimizer</li> </ol> Note <p>For hyperparameter optimization, make sure to install climatrix with: <code>pip install climatrix[optim]</code></p>"},{"location":"tutorial/#step-m-interactive-plotting","title":"\ud83c\udf0d Step M: Interactive plotting","text":"<p>You can interactively plot the resulting dataset. Just run</p> <pre><code>cm.plot.Plot(dataset=cm_ds).show(port=5000)\n</code></pre> <p>That will run locally the server and enables you to conveniently explore the dataset via web browser.</p> Tip <p>If the preview does not open, choose your faviourite web browser and open <code>[http://localhost:5000/](http://localhost:5000/)</code> if you selected port <code>5000</code>.</p> Note <p>For interactive plotting, make sure to install climatrix with: <code>pip install climatrix[plot]</code></p>"}]}